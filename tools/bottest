#!/bin/bash --norc

# Copyright (c) 2015, the Dart Team. All rights reserved. Use of this
# source code is governed by a BSD-style license that can be found in
# the LICENSE file.

# This runs a sequence of commands that corresponds to the test procedure
# executed by a package bot, such that it can be detected with greater
# certainty whether or not a given package will have a successful test
# run when it is 'git cl land'-ed.  The commands used for each test and
# the set of tests is faithful to the corresponding things on the
# package bots.  A source of discrepancies is the availability of
# installed software: It is possible to have a successful local run and
# then a failing package bot run if the local run relied on installed
# software (existence or location) which is not available on the package
# bot.

show_section () {
  echo "---------------------------------------- $1"
}

function setup {
  show_section cleanup
  echo Removing $BOTTEST_DART_REPO
  rm -rf $BOTTEST_DART_REPO

  show_section setup
  mkdir -p $BOTTEST_DART_REPO
  cd $BOTTEST_DART_REPO
  gclient config https://github.com/dart-lang/package-bots/trunk
  gclient sync

  cd $BOTTEST_DART_REPO/dart/third_party
  rm -rf package-bots
  git clone https://github.com/dart-lang/package-bots.git

  mkdir pkg
  cd pkg
  ln -s $BOTTEST_LOCAL_PKG $BOTTEST_PKG
}

function run_annotated_steps {
  show_section run

  tmpfile=$BOTTEST_DART_REPO/testlog.log
  cd $BOTTEST_DART_REPO/dart
  BUILDBOT_BUILDERNAME=packages-linux-$BOTTEST_PKG \
    third_party/package-bots/annotated_steps.py |\
    tee $tmpfile
  grep '^=== [a-zA-Z0-9]' $tmpfile
  echo Log is in $tmpfile
}

# Sets up the following
# BOTTEST_DART_REPO: path to location where tests are performed.
# BOTTEST_LOCAL_PKG: path to root of local copy of package.
# BOTTEST_PKG: name of package for which the tests are performed.
function set_variables {
  # This script expects to be in tools/ in the package to be tested.
  BOTTEST_LOCAL_PKG="$(realpath "$(dirname "${BASH_SOURCE[0]}")"/..)"
  # The name of the package is what comes after the last '/'.
  BOTTEST_PKG="${BOTTEST_LOCAL_PKG##*/}"
  BOTTEST_DART_REPO="/tmp/bottest-$BOTTEST_PKG"
  echo Testing BOTTEST_PKG at $BOTTEST_LOCAL_PKG
}

original_dir=$(pwd)
# No matter how this script exits, go back do the original working directory.
trap 'cd $original_dir' EXIT

set_variables
while [ -n "$1" ]; do
  case $1 in
    (--use-existing-bottest) useExisting="true" ; shift ;;
    (--help) echo "Usage: $0 [--help] [--use-existing-bottest]"; exit 0;;
    (*) echo "$0: Argument '$1' not understood. Exiting."; exit -1;;
  esac
done

if [ -n "$useExisting" ]; then
  if [ ! -d $BOTTEST_DART_REPO ]; then
    echo "No existing bottest directory found at $BOTTEST_DART_REPO"
    exit -1
  fi
  echo reusing the bottest directory at $BOTTEST_DART_REPO.
else
  setup
fi

run_annotated_steps
